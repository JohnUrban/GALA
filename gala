#!/usr/bin/env python3
################################################################
#  This file part of GALA Gap-free Long-reads Assembler        #
#  Author: Mohamed awad                                        #
#  Company: Xiangchao Gan lab (MPIPZ)                          #
#  Released under the (MIT) license (see LICENSE file)         #
#  This file has been updated by John Urban.                   #
################################################################



##########################################################################################################################
## GLOBAL MODULES
##########################################################################################################################
import os, sys, argparse


##########################################################################################################################
## LOCAL MODULES
##########################################################################################################################
scr='src'
path=os.path.dirname(os.path.abspath(__file__))
absolute=os.path.join(path,scr)
sys.path.insert(0, absolute)
from comp_generator import comp_generator
from cut_gathering import cut_gathering
from new_genome import genomes
from scaffolding import scaffolding
from bam_seprator import bam_seprator
from read_extract import read_extract


##########################################################################################################################
## PARSE ARGUMENTS
##########################################################################################################################
## Init.
parser = argparse.ArgumentParser(prog="gala",
                                 usage='%(prog)s -h  [options] <draft_names & paths> <fa/fq> <reads> <platform>',
                                 description='GALA Gap-free Long-reads Assembler')

## Add args.
parser.add_argument("draft_names", nargs=1, type=str, help='Draft names and paths\t[required]')
parser.add_argument("input_file", nargs=1, type=str, help='input type (fq/fa) \t[required]')
parser.add_argument("reads", nargs=1, type=str, help='raw/corrected reads\t[required]')
parser.add_argument("sequencing_platform", nargs=1, type=str, help='\n\tpacbio-raw\n\tpacbio-corrected\n\tnanopore-raw\n\tnanopore-corrected\n\t\t[required]')
parser.add_argument("-a",nargs='*', type=str, default=['canu'], help='Chr-by_Chr assembler (canu flye miniasm) \t [default canu]',dest="assembler")
parser.add_argument("-b",nargs=1, type=int, default=[5000], metavar='Alignment block length\t [default 5000]',dest="block")
parser.add_argument("-p",nargs=1, type=int, default=[70], metavar='Alignment identity percentage\t [default 70%]',dest="percent")
parser.add_argument("-l",nargs=1, type=int, default=[1], metavar='lowest number of misassemblies indecator\t [default 1]',dest="lowest")
parser.add_argument("-c",nargs=1, type=int, default=[5000], metavar='Shortest contig length\t [default 5000]',dest="contig")
parser.add_argument("-k",nargs=1, type=int, default=[175], metavar='Mis-assembly block\t [default 175]\n\t\t\tIt is better to extend the misassembly block in case of\n\t\t\tunpolished assemblies or expected mis-assemblies\n\t\t\tin highly repetative regions (5000-10000)',dest="cutblock")
parser.add_argument("-q",nargs=1, type=int, default=[20], metavar='Mapping quality\t [default 20]',dest="qty")
parser.add_argument("-f",nargs=1, type=str, default=['gathering'], metavar='Output files name\t[default gathering]',dest="name")
parser.add_argument("-t",nargs=1, type=str, default=['False'], metavar='cut on a threshold passed by -u\t[default False]',dest="threshold")
parser.add_argument("-u",nargs=1, type=int, default=[3], metavar='threshold cut value\t[default 3]',dest="threshold_value")
parser.add_argument("--cut1",nargs=1, type=int, default=[50000], metavar='The length of the smallest discordance on contigs of length >= 1000000  \t[default 50000]\n\t\t Be very careful with this parameter',dest="diff_1")
parser.add_argument("--cut2",nargs=1, type=int, default=[25000], metavar='The length of the smallest discordance on contigs of length >= 100000  \t[default 25000]\n\t\t Be very careful with this parameter',dest="diff_2")
parser.add_argument("--cut3",nargs=1, type=int, default=[15000], metavar='The length of the smallest discordance on contigs of length >= 5000  \t[default 15000]\n\t\t Be very careful with this parameter',dest="diff_3")
parser.add_argument("-o",nargs=1, type=str, default=[os.getcwd()], metavar='output files path\t[default current directory]',dest="output")
parser.add_argument('-v','--version', action='version', version='%(prog)s 1.0.1')


## Speeding up the Gala pipeline
parser.add_argument("--threads", type=int, default=4, dest="threads", help='''Number of threads to use with Minimap2 and BWA.''')
parser.add_argument("--fastmode", action='store_true', default=False, help='''Use Minimap2 for read-mapping steps instead of BWA.''')
parser.add_argument("--resume", action='store_true', default=False, help='''GALA will look for last successfully completed step, and continue (resume). It will redo any steps along pipeline that do not have Step_xxx.done touch files...''')
parser.add_argument("--continue_from", type=int, default=1, help='''GALA will look try to start from step specified:
	1 = Beginning of the pipeline (generating draft_compare.sh script to run).
	2 = Running draft_compare.sh. 
	3 = Identify mis-assembled contigs.
	4 = Produce misassembly-free drafts.
	5 = Generate script to compare the misassembly-free drafts.
	6 = Run draft_comparison file to produce new drafts comparison paf files.
	7 = Run the ccm module to produce contigs scaffolding groups.
	8 = Map all drafts against raw long reads and self-corrected reads if available.
	9 = Separate the read names mapped to each contig.
	10 = Concatenate read name files belongs to the same scaffolding group.
	11 = Use the readsep Module to separate each scaffold correlated-reads.
	12 = Run assemblies.
	''')

## High quality read data options
parser_hq = parser.add_mutually_exclusive_group(required=False)
parser_hq.add_argument("--hifi", action='store_true', default=False, help='''Use this flag if long read data is >99 pct accuracy on average. Default : assumes false. Affects some paramter choices. Typically for PacBioHiFi, but perhaps can work with Nanopore Q20/Q30 chemistry (avg accuracy >99 pct).''')
parser_hq.add_argument("--sac", action='store_true', default=False, help='''Use this flag if nanopore data is >90-95 pct accuracy on average (e.g. super accurate basecalling mode, SAC). Default : assumes false. Affects some paramter choices. See: https://github.com/marbl/canu/issues/2121 ''')
parser.add_argument("--forcetrim", action='store_true', default=False, help='''Optional use with --sac option to force end trimming of reads in Canu pipeline. See: https://github.com/marbl/canu/issues/2121''')

## Additional argments to various assemblers:
parser.add_argument("--tellcanu", type=str, default="", help='''Put additional parameters to feed Canu in quotes.''')
parser.add_argument("--tellflye", type=str, default="", help='''Put additional parameters to feed Flye in quotes.''')
parser.add_argument("--tellminiasm", type=str, default="", help='''Put additional parameters to feed Miniasm in quotes.''')

## Debug messages (for development purposes)
parser.add_argument('--debug', action='store_true', default=False)

## TO POTENTIALLY BE INCLUDED IN FUTURE
#parser.add_argument("--hq", action='store_true', default=False, help='''Use this flag if long read data is >90% identity on average. Default : assumes false. Affects some paramter choices.''')

## Parse.
args = parser.parse_args()


##########################################################################################################################
## PROCESS ARGS
##########################################################################################################################
draft_names=args.draft_names[0]
draft_names=os.path.abspath(draft_names)
reads=args.reads[0]
reads=os.path.abspath(reads)
input_file=args.input_file[0]
platform=args.sequencing_platform[0]
block=args.block[0]
threshold_value=args.threshold_value[0]
threshold=args.threshold[0]
if threshold in ('False','false','FALSE','F','f'):
    theshold=False
elif threshold in ('True','true','TRUE','T','t'):
    theshold=True
cutblock=args.cutblock[0]
percent=args.percent[0]
qty=args.qty[0]
output=args.output[0]
output=os.path.abspath(output)
name=args.name[0]
contig=args.contig[0]
diff_1=args.diff_1[0]
diff_2=args.diff_2[0]
diff_3=args.diff_3[0]
assembler=args.assembler

## ARGS REGARDING HOW TO PROCEED
continuefrom = args.continue_from
passdonesteps = args.resume

## ARGS REGARDING MAPPING AND ASSEMBLING
if 'pacbio' in platform:
    bwatype     = "-x pacbio"
    mm2type     = "-x map-pb"
    mm2type_asm = "-x ava-pb"
elif 'nanopore' in platform:
    bwatype     = "-x ont2d"
    mm2type     = "-x map-ont"
    mm2type_asm = "-x ava-ont"


## Flye platform (keep this above HQ updates below)
flyeplatform = platform.replace('nanopore','nano').replace('corrected','corr')

## Updates if high quality (HQ) settings used
if args.hifi:
    mm2type      = "-x map-hifi"
    platform     = "pacbio-hifi"
    flyeplatform = "pacbio-hifi"
elif args.sac:
    ## if pacbio data and --sac specified, just default to corrected pacbio params, not hifi.
    flyeplatform = flyeplatform.replace('corr','hq').replace('raw','hq') if 'nano' in flyeplatform else 'pacbio-corr' 
    platform     = "pacbio-hifi 'batOptions=-eg 0.10 -sb 0.01 -dg 2 -db 1 -dr 3'"
    if args.forcetrim:
       platform += "-untrimmed"


## Extra parameters to feed mappers and assemblers
extraBWAparameters=' '.join(['-t', str(args.threads), bwatype])
extraMM2parameters_asms=' '.join(['-t', str(args.threads)])
extraMM2parameters_reads=' '.join(['-t', str(args.threads), mm2type])
extraCANUparameters = args.tellcanu
extraFLYEparameters = args.tellflye
extraMINIASMparameters = args.tellminiasm


## DEBUG MESSAGE : Useful even when not debugging.
if args.debug:
    print("\nInput args ::\n")
    print(args)
    print("\nUpdated args ::\n")
    all_args = dict(draft_names=draft_names, reads=reads, input_file=input_file, platform=platform, flyeplatform=flyeplatform, block=block, 
                    threshold_value=threshold_value, threshold=threshold, cutblock=cutblock, percent=percent,
                    qty=qty, output=output, name=name, contig=contig, diff_1=diff_1, diff_2=diff_2, diff_3=diff_3,
                    assembler=assembler, bwatype=bwatype, mm2type=mm2type, mm2type_asm=mm2type_asm, extraBWAparameters=extraBWAparameters, 
                    extraMM2parameters_asms=extraMM2parameters_asms, extraMM2parameters_reads=extraMM2parameters_reads, extraCANUparameters=extraCANUparameters,
                    extraFLYEparameters=extraFLYEparameters, extraMINIASMparameters=extraMINIASMparameters)
    for k,v in list(all_args.items()):
        print('\t'.join(str(e) for e in [k,v]))
    print("Starting.....\n")
    sys.stdout.flush()

##########################################################################################################################
## SET UP WORKING DIRECTORY
##########################################################################################################################
try:
    os.chdir(output)
except:
    os.mkdir(output)
    os.chdir(output)
try:
    os.mkdir('gala_results')
except:
    pass
new_dir=os.path.join(output,'gala_results')
os.chdir(new_dir)
workdir=os.getcwd()
MAINDIR=workdir
PROGDIR=workdir + '/progress'
os.makedirs(PROGDIR, exist_ok=True)

##########################################################################################################################
## HELPER FXNS
##########################################################################################################################
def touch(x):
    os.system("touch " + PROGDIR + "/" + x)

def step_successful(exitcode):
    if exitcode == 0:
        return True
    return False

def quit_and_explain(msg):
    print(msg)
    quit()

def assess_progress(exitcode, step):
    if step_successful(exitcode):
        print(step+ 'completed successfully.... moving on.\n')
        touch(step+'.done')
        sys.stdout.flush()
    else:
        quit_and_explain(step+' failed... exiting....\n')

def dostep(step, continefrom, passdonesteps):
    n = int(step.split('_')[1])
    if continuefrom > 1: # User indicated a step to force continue from.
        print("\nContinue from Step" + str(continuefrom) + " selected.")
        if n >= continuefrom:
            print(step + " is >= " + str(continuefrom) + ", so GALA will perform this step.\n")
            return True
        else:
            print(step + " is < " + str(continuefrom) + ", so GALA will NOT perform this step.\n")
            return False
    elif passdonesteps: # Continue from left as 1, perhaps user wanted GALA to find last successful step. 
        print("\nContinue selected: steps w/o progress touch files will be performed.")
        touchfile = PROGDIR + "/" + step + '.done'
        if os.path.isfile( touchfile ):
            print("Found " + touchfile + "\nTherefore, GALA skipping " + step + " ...\n")
            return False
        else:
            print("Touchfile for " + step + " Not Found.\nTherefore, GALA will perform this step ...\n")
            return True
    else:	## continuefrom == 1 and passdonesteps==False ; do the step... it ought to start at Step1, and allow all subsequent steps to run.
        print("\nGALA performing " + step + " ....\n")
        return True

##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Mis Assembly Detector Module (MDM)
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Draft assembly comparisons (whole genome alignments with Minimap2)
## Generate mis-assembly-free draft assemblies
##########################################################################################################################

##########################################################################################################################
## 1. Use the comp module to generate a draft_comparison file.
##########################################################################################################################
if dostep('Step_1', continuefrom, passdonesteps):
    sys.stdout.flush()
    comp_generator(genomes=draft_names,
                   output=workdir,
                   mm2params=extraMM2parameters_asms)
    op=''.join(list(open('draft_comp.sh')))
    op=op.replace('comparison','preliminary_comparison')
    om=open('draft_comp.sh','w')
    om.writelines(op)
    om.close()

    # DONE ; Quit if exitcode non-zero; make touch file otherwise ; TODO: come up with check here.
    assess_progress(0, 'Step_1')


##########################################################################################################################
## 2. Run draft_comparison file to produce drafts comparison paf files.
##########################################################################################################################
if dostep('Step_2', continuefrom, passdonesteps):
    sys.stdout.flush()
    exitcode = os.system('sh draft_comp.sh')
    path_to_paf='preliminary_comparison'
    
    ## Quit if exitcode non-zero; make touch file otherwise
    assess_progress(exitcode, 'Step_2')



##########################################################################################################################
## 3. Use the mdm module to identify mis-assembled contigs.
##########################################################################################################################
if dostep('Step_3', continuefrom, passdonesteps):
    sys.stdout.flush()
    number_of_drafts=''.join(list(open(draft_names))).count('=')

    cut_gathering(path=path_to_paf,
                  number_of_drafts=number_of_drafts,
                  block=block,
                  percentage=percent,
                  shortage_contig=contig,
                  quality=qty,
                  out_file=True,
                  out_name=name,
                  out_path=workdir,
                  cut_block=cutblock,
                  threshold=threshold,
                  threshold_value=threshold_value,
                  diff_1=diff_1,
                  diff_2=diff_2,
                  diff_3=diff_3)

    ## TODO: come up with success-check for this step
    assess_progress(0, 'Step_3')

##########################################################################################################################
## 4. Use the newgenome module to Produce misassembly-free drafts. :: gala_results/new_genomes/new_draft_names_paths.txt is made here.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP
new_path=workdir+'/'+'new_genomes/'
try:
    os.mkdir('new_genomes')
except:
    pass



## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT
if dostep('Step_4', continuefrom, passdonesteps):
    sys.stdout.flush()

    genomes(genomes=draft_names, 
            gathering=os.path.join(workdir,name), 
            gathering_name=name, 
            outpath=new_path)


    ##        outpath=workdir+'/new_genomes')		## Used varname established above since it was same::=>     outpath=workdir+'/new_genomes'
    ### new_path=workdir+'/'+'new_genomes/' 		## NOW ABOVE IF STATEMENT, USED REGARDLESS OF DO/SKIP.
    
    ## TODO: come up with success-check for this step
    assess_progress(0, 'Step_4')


##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Contig Clustering Module (CCM)
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Updated draft assembly comparisons (whole genome alignments with Minimap2)
## Identifying contig clusters
##########################################################################################################################


##########################################################################################################################
## 5. Use the comp module to generate a draft_comparison file for misassembly-free drafts.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP
outpath=workdir+'/gap_free_comp'
try:
    os.mkdir('gap_free_comp')
except:
    pass


## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT
if dostep('Step_5', continuefrom, passdonesteps):
    sys.stdout.flush()

    ##outpath=workdir+'/gap_free_comp' 		## NOW ABOVE IF STATEMENT, USED REGARDLESS OF DO/SKIP.

    comp_generator(genomes=new_path+'new_draft_names_paths.txt', 
                   output=outpath,
                   mm2params=extraMM2parameters_asms)



## POST-STEP COMMANDS THAT MAY BE NEEDED EVEN IF SKIPPING STEP
new_path=outpath
os.chdir(outpath)
print("\nStep 5 : changedir : " + outpath + "\n")

## TODO: come up with success-check for this step
assess_progress(0, 'Step_5')


##########################################################################################################################
## 6. Run draft_comparison file to produce new drafts comparison paf files.
##########################################################################################################################


if dostep('Step_6', continuefrom, passdonesteps):
    sys.stdout.flush()
    exitcode = os.system('sh draft_comp.sh')

    ## Quit if exitcode non-zero; make touch file otherwise
    assess_progress(exitcode, 'Step_6')

##########################################################################################################################
## 7. Run the ccm module to produce contigs scaffolding groups.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP
path_to_drafts='comparison'


## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT
if dostep('Step_7', continuefrom, passdonesteps):
    sys.stdout.flush()
    scaffolding(path='comparison',
                number_of_drafts=number_of_drafts,
                block=block,
                percentage=percent,
                shortage_contig=contig,
                quality=qty,
                out_file=True,
                output_name=name,
                output=outpath,
                diff_1=diff_1,
                diff_2=diff_2,
                diff_3=diff_3)

    ## TODO: come up with success-check for this step
    assess_progress(0, 'Step_7')

##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Scaffolding Group Assembly Module (SGAM)
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
## Map reads to updated drafts
## For each draft, partition reads into groups based on contigs they map to
## Join reads based on contig clusters
## Assemble reads in each cluster separately
##########################################################################################################################



##########################################################################################################################
## 8. Map all drafts against raw long reads and self-corrected reads if available.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP
new_path=output+'/'+'new_genomes/'
CD = workdir+'/new_genomes'
os.chdir( CD )					## Only needed if doing BWA indexing, but will keep outside/above here anyway.
print("\nStep 8 : changedir : " + CD + "\n")

## BWA INDEXING
if not args.fastmode:
    sub_step_name = 'Step_8_bwaidx'
    if dostep(sub_step_name, continuefrom, passdonesteps):
        sys.stdout.flush()
        CMD = 'for i in *.fa; do bwa index $i; done'
        print("\n" + CMD + "\n")
        sys.stdout.flush()
        exitcode = os.system(CMD)
    
        ## Quit if exitcode non-zero; make touch file otherwise
        assess_progress(exitcode, 'Step_8_bwaidx')

## MAY BE NEEDED EVEN IF SKIPPING STEP
## CHANGE DIR: GO BACK TO WORKDIR
os.chdir(workdir)
print("\nStep 8 : changedir : " + workdir + "\n")

## SET UP FOR BWA (or MM2) MAPPING
## 	 MAKE "mapping" DIR
try:
    os.mkdir('mapping')
except:
    pass

## SET UP FOR BWA (or MM2) MAPPING
## 	 MAKE "mapping" SUBDIRs
mapping = list(open('new_genomes/new_draft_names_paths.txt'))		## mapping variable also needed in subsequent steps.
for i in mapping:
    dirname=i.strip().split('=')[0]
    os.system('mkdir -p mapping/'+dirname)


## MAPPING STEPS
map_step_name = 'Step_8_mappingloop'
if dostep(map_step_name, continuefrom, passdonesteps):
    ## Perform read mapping.
    for i in mapping:
        dirname  = i.strip().split('=')[0]
        genomdir = i.strip().split('=')[1]
        ##SAMPIPE=''.join(['| samtools sort | samtools view -Sb > mapping/', dirname, '/mapping.bam'])
        ## Default output of samtools sort is already BAM; also above command lacked -h flag, so header was missing.
        SAMPIPE=''.join(['| samtools sort > mapping/', dirname, '/mapping.bam'])
        SAMIDXCMD=''.join(['samtools index mapping/', dirname, '/mapping.bam'])
        ## GET MAPPING COMMAND (MAPCMD)
        if not args.fastmode:
            ## USE BWA
            MAPCMD=' '.join(['bwa mem', extraBWAparameters, genomdir, reads, SAMPIPE])
            #os.system('bwa mem '+genomdir+' '+reads+'| samtools sort | samtools view -Sb > mapping/'+dirname+'/mapping.bam')
            #os.system('samtools index mapping/'+dirname+'/mapping.bam')
        else:
            ## Use Minimap2
            ##MAPCMD=' '.join(['minimap2 -a -x asm5', extraMM2parameters_reads, genomdir, reads, SAMPIPE])
            MAPCMD=' '.join(['minimap2 -a', extraMM2parameters_reads, genomdir, reads, SAMPIPE])

        ## EXECUTE
        sub_step_name = 'Step_8_mapping_'+dirname
        if dostep(sub_step_name, continuefrom, passdonesteps):
            print("\n" + MAPCMD + "\n")
            sys.stdout.flush()
            exitcode = os.system(MAPCMD)
        
            ## Quit if exitcode non-zero; make touch file otherwise
            assess_progress(exitcode, sub_step_name)

        sub_step_name = 'Step_8_samtoolsindex_'+dirname
        if dostep(sub_step_name, continuefrom, passdonesteps):
            print("\n" + SAMIDXCMD + "\n")
            sys.stdout.flush()
            exitcode = os.system(SAMIDXCMD)

            ## Quit if exitcode non-zero; make touch file otherwise
            assess_progress(exitcode, sub_step_name)


    ## Quit if exitcode non-zero; make touch file otherwise
    ## If made it here, it appears Step8 was successsful, but may need a more thorough check in the future.
    assess_progress(0, map_step_name)



##########################################################################################################################
## 9. Use the following commands to separate the read names mapped to each contig
##########################################################################################################################
##	samtools view -H bam_file |grep "SQ"|cut -f 2|cut -d : -f 2 > contig_names
##	seprator contig_names mapping.bam
##	sh bam_seprator.sh
##	for i in bams/*; do samtools view $i | cut -f 1 > $i.read_names;done;
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP

new_path=workdir+'/'+'mapping/'
#os.chdir(workdir+'/mapping')	## Uses same dir established as "new_path", so commented out, and added next line.
os.chdir(new_path)



## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT

if dostep('Step_9', continuefrom, passdonesteps):
    sys.stdout.flush()
    print("\nStep 9 : changedir : " + new_path + "\n")

    for i in mapping:
        dirname = i.split('=')[0]

        if dostep('Step_9_contignames_'+dirname, continuefrom, passdonesteps):
            WD = new_path+dirname
            print("\nStep 9 : WD : " + WD )
            os.chdir(WD)
            CMD = 'samtools view -H mapping.bam | grep SQ | cut -f 2 | cut -d : -f 2 > contig_names'
            print("\n" + CMD + "\n")
            sys.stdout.flush()
            exitcode = os.system(CMD)
        
            ## Quit if exitcode non-zero; make touch file otherwise
            assess_progress(exitcode, 'Step_9_contignames_'+dirname)

    for i in mapping:
        dirname = i.split('=')[0]
        print("\nStep 9 : bam_seprator : " + dirname + " \n") 
        sys.stdout.flush()

        bam_seprator(contig_name=new_path+dirname+'/contig_names',
                     bam_file=new_path+dirname+'/mapping.bam',
                     out_put_path=new_path+dirname)

        CD = new_path+dirname
        os.chdir( CD )
        print("\nStep 9 : changedir : " + CD + "\n")


        if dostep('Step_9_shbamseprator_'+dirname, continuefrom, passdonesteps):
            print('Step_9 : sh bam_seprator.sh : ' + dirname + '\n')
            sys.stdout.flush()
            exitcode = os.system('sh bam_seprator.sh')

            ## Quit if exitcode non-zero; make touch file otherwise
            assess_progress(exitcode, 'Step_9_shbamseprator_'+dirname)

        if dostep('Step_9_readnames_'+dirname, continuefrom, passdonesteps):
            WD = new_path+dirname+'/bams'
            os.chdir(WD)
            print("\nStep 9 : WD : " + WD )
            CMD = 'for i in * ; do samtools view $i | cut -f 1 > $i.read_names ; done ;'
            print("\n" + CMD + "\n")
            exitcode = os.system('for i in *; do samtools view $i | cut -f 1 > $i.read_names;done;')

            ## Quit if exitcode non-zero; make touch file otherwise
            assess_progress(exitcode, 'Step_9_readnames_'+dirname)

    ## Quit if exitcode non-zero; make touch file otherwise
    assess_progress(0, 'Step_9')
    sys.stdout.flush()


##########################################################################################################################
## 10. Use the cat command to concatenate read name files belongs to the same scaffolding group.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP
dirnames=[]
for i in mapping:
    dirnames.append( i.strip().split('=')[0] )

scaffs	= os.path.join(outpath,name)
li 	= os.listdir(scaffs)

ok = {}
for i in dirnames:
    ok[i]={}



## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT

if True:		## dostep('Step_10', continuefrom, passdonesteps):
    			## There is code in this entire block needed in downstream steps; 
			## for example, updating the "ok" dictionary.
			## Can potentially bring write an else-statement w/ downstream needs at a later date (to avoid over-writing previous files).
    print("\nStep 10 : CWD : " + os.getcwd() + "\n")
    sys.stdout.flush()

    for base in dirnames:
        op = list(open(scaffs+'/'+name+'_'+base+'.scaff'))
        oa = open(new_path+base+'/scaffolds','w')
        oa.writelines('cd bams\n')

        nn = 1
        for bas in op:
            if bas[:6]=='scaff_':
                rr  = bas.split('\t')
                rmn = rr[-2]
                rr  = rr[:-2]
                rr  = '\t'.join(rr[1:]).replace('\n','')
                rr  = rr.replace('\t','.bam.read_names ')
                rr  = 'cat '+rr+'.bam.read_names > ../scaffold_'+str(nn)+'.read_names\n'

                ok[base]['scaffold_'+str(nn)] = str(rmn).replace('\n','')
                oa.writelines(rr)
                nn = nn+1
        oa.close()

    ## TODO: come up with success-check for this step
    assess_progress(0, 'Step_10')

##########################################################################################################################
## 11. Use the readsep Module to separate each scaffold correlated-reads.
##########################################################################################################################

## MAY BE NEEDED EVEN IF SKIPPING STEP


## DO STEP IF NEEDED OR REQUESTED, PASS IF NOT
if dostep('Step_11', continuefrom, passdonesteps):
    print("\nStep 11 : CWD : " + os.getcwd() + "\n")
    sys.stdout.flush()

    for i in dirnames:
        CD = os.path.join(new_path,i)
        os.chdir( CD )
        print("\nStep 11 : sh scaffolds : changedir : " + CD + "\n")
        sys.stdout.flush()
        exitcode = os.system('sh scaffolds')

        ## Quit if exitcode non-zero; make touch file otherwise
        assess_progress(exitcode, 'Step_11_scaffolds' + i )

        mm = list(open('scaffolds'))[1:]

        for base in mm:
            mn = base.split(' > ../')[-1].replace('\n','')
            print("\nStep 11 : read_extract : \n\t reads : " + reads + "\n\t mn : " + mn + "\n\t input_file : " + input_file + "\n")
            sys.stdout.flush()
            read_extract(reads, mn, input_file)

    ## TODO: come up with success-check for this step
    assess_progress(0, 'Step_11')

##########################################################################################################################
## 12. Implement Chromosome-by-Chromosome assembly approach to retrieve the gap-free chromosome-scale assembly by
##########################################################################################################################
## NOT PUTTING AN IF_DOSTEP HERE FOR NOW: in the majority of circumstances, the user will not be intending to skip the entire pipeline.
print("\nStep 12 : CWD : " + os.getcwd() + "\n")
sys.stdout.flush()

## WRITE SCRIPT FOR ASSEMBLIES

if 'canu' in assembler:
    for i in dirnames:
        rmn = open(new_path+i+'/assembly_c.sh','w')
        CD  = os.path.join(new_path,i)
        os.chdir( CD )
        print("\nStep12 : canu loop : changedir : " + CD + "\n")
        sys.stdout.flush()
        mm  = list(open('scaffolds'))[1:]
        for base in mm:
            mn      = base.split(' > ../')[-1].replace('.read_names\n','.read.fq')
            px      = mn.replace('.read.fq','')
            gs      = str(int(ok[i][px])/1000000)
            npimn   = new_path + i + '/' + mn
            CANUCMD = ' '.join(['canu -p canu_'+px, ' -d canu_'+px, extraCANUparameters, 'genomeSize='+gs+'m', '-'+platform, npimn])
            ####rmn.writelines('canu -p canu_'+mn.replace('.read.fq','')+ ' -d canu_'+mn.replace('.read.fq','')+' genomeSize='+str(int(ok[i][mn.replace('.read.fq','')])/1000000)+ 'm -' +platform+' '+new_path+i+'/'+mn+'\n')
            rmn.writelines(CANUCMD+'\n')
            print(CANUCMD+"\n")
            sys.stdout.flush()

if 'flye' in assembler:
    for i in dirnames:
        rmn = open(new_path+i+'/assembly_f.sh','w')
        CD  = os.path.join(new_path,i)
        os.chdir( CD )
        print("\nStep12	: Flye loop : changedir	: " + CD + "\n")
        sys.stdout.flush()
        mm  = list(open('scaffolds'))[1:]
        for base in mm:
            mn      = base.split(' > ../')[-1].replace('.read_names\n','.read.fq')
            px      = mn.replace('.read.fq','')
            gs      = str(int(ok[i][mn.replace('.read.fq','')])/1000000)
            npimn   = new_path+i+'/'+mn
            cddir   = workdir+'/chr_by_chr/'+i
            FLYECMD = ' '.join(['flye --out-dir flye_'+px, extraFLYEparameters, '--genome-size', gs+'m', '--'+flyeplatform, npimn])

            rmn.writelines('cd ' + cddir + '\n')
            rmn.writelines('mkdir -p flye_'+px + '\n')
            rmn.writelines('cd flye_'+px + '\n')
            rmn.writelines(FLYECMD+'\n')
            print(FLYECMD+"\n")
            sys.stdout.flush()

if 'miniasm' in assembler:
    for i in dirnames:
        rmn = open(new_path+i+'/assembly_m.sh','w')
        CD  = os.path.join(new_path,i)
        os.chdir( CD )
        print("\nStep12 : Miniasm loop : changedir : " + CD + "\n")
        sys.stdout.flush()
        mm  = list(open('scaffolds'))[1:]
        for base in mm:
            mn         = base.split(' > ../')[-1].replace('.read_names\n','.read.fq')
            px         = mn.replace('.read.fq','')
            cddir      = workdir+'/chr_by_chr/'+i
            READS      = new_path+i+'/'+mn
            OVERLAPS   = px+'.paf.gz'
            GFA        = px+'.gfa'
            FA         = px+'.fa'
            GZIPPIPE   = '| gzip -1 > ' + OVERLAPS
            MM2CMD     = ' '.join(['minimap2', mm2type_asm, READS, READS, GZIPPIPE])
            MACMD      = ' '.join(['miniasm -f', READS, OVERLAPS, '>', GFA])
            FLYEPOLCMD = ' '.join(['flye --polish-target', FA, '--out-dir .', '--'+ flyeplatform, READS, '--iterations 3'])

            rmn.writelines('cd ' + cddir + '\n')
            rmn.writelines('mkdir -p miniasm_'+px+'\n') 
            rmn.writelines('cd miniasm_'+px + '\n')
            rmn.writelines(MM2CMD+'\n')
            rmn.writelines(MACMD+'\n')
            rmn.writelines("awk " + "'/^S/{print " + '">"$2"\\n"$3}' + "' " + GFA + ' > ' + FA + '\n')
            rmn.writelines(FLYEPOLCMD+'\n')
            print(MM2CMD + "\n" + MACMD + "\n" + FLYEPOLCMD + "\n")
            sys.stdout.flush()

## EXECUTE ASSEMBLIES
os.chdir(workdir)
print("\nStep12 : EXECUTE : changedir : " + workdir + "\n")
sys.stdout.flush()

try:
    os.mkdir('chr_by_chr')
except:
    pass

CD = workdir+'/chr_by_chr'
os.chdir(CD)
print("\nStep12 : EXECUTE : changedir : " + CD + "\n")
sys.stdout.flush()

for i in mapping:
    dirname = i.split('=')[0]
    try:
        os.mkdir(workdir+'/chr_by_chr/'+dirname)
    except:
        pass
    CD = workdir+'/chr_by_chr/'+dirname
    os.chdir( CD )
    print("\nStep12 : EXECUTION LOOP : changedir : " + CD)
    CMD = 'sh '+new_path+dirname+'/assembly_*.sh'
    print(CMD+"\n")
    sys.stdout.flush()
    os.system(CMD)






## VERSION
sys.stdout.flush()
if '-v':
	parser.parse_args(['-v'])
